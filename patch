diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index d848198..d2cc349 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -504,13 +504,21 @@ packet_routed:
 	skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));
 	skb_reset_network_header(skb);
 	iph = ip_hdr(skb);
+	if(sk->sk_protocol == 18) {
+		tos = tos | 1;
+	}
 	*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (tos & 0xff));
 	if (ip_dont_fragment(sk, &rt->dst) && !skb->ignore_df)
 		iph->frag_off = htons(IP_DF);
 	else
 		iph->frag_off = 0;
 	iph->ttl      = ip_select_ttl(inet, &rt->dst);
-	iph->protocol = sk->sk_protocol;
+        if(sk->sk_protocol == 18) {
+		iph->protocol = 6;
+        } else {
+		iph->protocol = sk->sk_protocol;
+	}
+
 	ip_copy_addrs(iph, fl4);
 
 	/* Transport layer set skb->h.foo itself. */
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 2fe2954..5f8ff2f 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1408,7 +1408,7 @@ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
 {
 	const struct net_offload *ops;
 	struct sk_buff *pp = NULL;
-	const struct iphdr *iph;
+	struct iphdr *iph;
 	struct sk_buff *p;
 	unsigned int hlen;
 	unsigned int off;
@@ -1424,7 +1424,10 @@ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
 		if (unlikely(!iph))
 			goto out;
 	}
-
+	if(iph->tos & 0x1) {
+		iph->protocol = 18;
+		iph->tos &= ~(1UL);  
+	}
 	proto = iph->protocol;
 
 	rcu_read_lock();
@@ -1438,9 +1441,10 @@ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
 	if (ip_is_fragment(iph))
 		goto out_unlock;
 
-	if (unlikely(ip_fast_csum((u8 *)iph, 5)))
+	if (unlikely(ip_fast_csum((u8 *)iph, 5) && proto != 18)) {
+		printk("fast cum failed proto:%d\n", proto);
 		goto out_unlock;
-
+	}
 	id = ntohl(*(__be32 *)&iph->id);
 	flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));
 	id >>= 16;
