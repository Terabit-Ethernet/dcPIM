diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 3ed7c98a98e1..7d0dbae059bf 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -34,6 +34,7 @@
 #endif
 #include <linux/bpf-netns.h>
 
+#define IPPROTO_DCPIM 0xFE
 static void dissector_set_key(struct flow_dissector *flow_dissector,
 			      enum flow_dissector_key_id key_id)
 {
@@ -1390,6 +1391,7 @@ bool __skb_flow_dissect(const struct net *net,
 		break;
 
 	case IPPROTO_TCP:
+	case IPPROTO_DCPIM:
 		__skb_flow_dissect_tcp(skb, flow_dissector, target_container,
 				       data, nhoff, hlen);
 		break;
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 2f94d221c00e..6b7e71a4e094 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1437,7 +1437,7 @@ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
 {
 	const struct net_offload *ops;
 	struct sk_buff *pp = NULL;
-	const struct iphdr *iph;
+	struct iphdr *iph;
 	struct sk_buff *p;
 	unsigned int hlen;
 	unsigned int off;
@@ -1453,7 +1453,14 @@ struct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)
 		if (unlikely(!iph))
 			goto out;
 	}
-
+        /* dcPIM change */
+        if(iph->tos & 0x1) {
+               if (unlikely(ip_fast_csum((u8 *)iph, 5)))
+                       goto out;
+               iph->protocol = 0xFE;
+               iph->tos &= ~(1UL);
+               ip_send_check (iph);
+        }
 	proto = iph->protocol;
 
 	rcu_read_lock();
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index c3efc7d658f6..7832a446ddc7 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -507,13 +507,22 @@ int __ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
 	skb_push(skb, sizeof(struct iphdr) + (inet_opt ? inet_opt->opt.optlen : 0));
 	skb_reset_network_header(skb);
 	iph = ip_hdr(skb);
+        /* dcPIM change */
+        if(sk->sk_protocol == 0xFE) {
+                tos = tos | 1;
+        }
 	*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (tos & 0xff));
 	if (ip_dont_fragment(sk, &rt->dst) && !skb->ignore_df)
 		iph->frag_off = htons(IP_DF);
 	else
 		iph->frag_off = 0;
 	iph->ttl      = ip_select_ttl(inet, &rt->dst);
-	iph->protocol = sk->sk_protocol;
+        /* dcPIM change */
+        if(sk->sk_protocol == 0xFE) {
+		iph->protocol = 6;
+        } else {
+                iph->protocol = sk->sk_protocol;
+        }
 	ip_copy_addrs(iph, fl4);
 
 	/* Transport layer set skb->h.foo itself. */
